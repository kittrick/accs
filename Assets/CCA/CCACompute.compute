#pragma kernel ResetKernel
#pragma kernel StepKernel
#pragma kernel SecondaryNoiseKernel

Texture2D<float> readTex;
SamplerState sampler_readTex;

Texture2D<float4> readMemTex;
RWTexture2D<float4> writeMemTex;

RWTexture2D<float> writeTex;
RWTexture2D<float4> outTex;

int rez;

int range;
int drawRange;
uint threshold;
uint nstates;
bool moore;

uint deadcount = 0;

float4 colors[21];

uint2 mouse;

// via "The Art of Code" on Youtube
float2 Random(float2 p) {
    float3 a = frac(p.xyx * float3(123.34, 234.34, 345.65));
    a += dot(a, a + 34.450);
    return frac(float2(a.x * a.y, a.y * a.z));
}

[numthreads(8, 8, 1)]
void ResetKernel(uint3 id : SV_DispatchThreadID)
{
    writeTex[id.xy] = (int)(Random(id.xy * .01).x * nstates);
}

// Convert HSB to RGB
float4 hsb2rgb(float3 c) {
    float3 rgb = clamp(abs(((c.x * 6.0 + float3(0.0, 4.0, 2.0)) % 6.0) -
        3.0) - 1.0, 0.0, 1.0);
    rgb = rgb * rgb * (2.0 - 2.0 * rgb);
    float3 o = c.z * lerp(float3(1.0, 1.0, 1.0), rgb, c.y);
    return float4(o.r, o.g, o.b, 1);
}

void Render(uint3 id, float state, int count)
{
    float s = state / (float)nstates;
    float c = count / (float)threshold;
    ////////////////////////////////////////////////
    // Basic
    if (false){
        outTex[id.xy] = s;
    }
    
    // Fade Basic
    if (false){
        outTex[id.xy] *= .4;
        outTex[id.xy] += s;
    }
    
    // Count
    if (false){
        outTex[id.xy] = c;
    }
    
    // Fade Count
    if (false){
        outTex[id.xy] *= .3;
        outTex[id.xy] += c;
    }
    
    ////////////////////////////////////////////////
    float3 hsb = float3(0, .9, 1);
    
    // Basic Color
    if (false) {
        hsb.x = s;
        outTex[id.xy] = hsb2rgb(hsb);
    }
    
    // Range Color
    if (false) {
        hsb.x = hsb.y = hsb.z = s;
        hsb.x = lerp(.3, .0, hsb.x);
        hsb.y += .7;
        hsb.z += .6;
        outTex[id.xy] = hsb2rgb(hsb);
    }
    
    // Fade Range Color
    if (false) {
        hsb.x = hsb.y = hsb.z = s;
        hsb.x = lerp(.3, .0, hsb.x);
        hsb.y += .7;
        hsb.z -= .5;
        hsb.z *= 5;
        hsb.z = clamp(hsb.z, 0, 1);
        outTex[id.xy] += hsb2rgb(hsb);
        outTex[id.xy] *= .7;
    }
    
    // TRY:
    // 3/15/19/M
    // Range Count Fade Color
    if(false) {
        hsb.x = hsb.y = hsb.z = c;
        //hsb.x = lerp(.4, 1, hsb.x);   // 1/3/4/M
        hsb.x = lerp(0, .1, hsb.x);     // 8/14/2/N
        hsb.y += .7;
        outTex[id.xy] += hsb2rgb(hsb);
        //outTex[id.xy] *= .90; // 1/3/4/M
        outTex[id.xy] *= .70;
    }
    
    // Random Color Generator
    if(true){
        outTex[id.xy] = colors[state];
    }
    
    ////////////////////////////////////////////////
    // Crop
    float d = distance(float2(rez / 2.0, rez / 2.0), id.xy) / (rez / 2.0);
    outTex[id.xy] *= smoothstep(.9, .8, d);
    
}

[numthreads(8, 8, 1)]
void StepKernel(uint3 id : SV_DispatchThreadID)
{
    // READ STATE
    uint state = readTex[id.xy];
    
    uint count = 0;
    uint next = state + 1 == nstates ? 0 : state + 1; // (preserves higher states)
    
    // DETERMINE WHETHER EACH DIRECTION CONTAINS NEXT
    for(int x = min(-(range + (readMemTex[id.xy].x * nstates)), -20); x <= range + max((readMemTex[id.xy].x * nstates), 20); x++){
        for(int y = min(-(range + (readMemTex[id.xy].x * nstates)), -20); y <= range + max((readMemTex[id.xy].x * nstates), 20); y++){
       
            // ignore self
            if((x == 0 && y == 0)){
                continue;
            }
            
            if(moore || (x == 0 || y == 0)){
                uint s = readTex.SampleLevel(sampler_readTex, (id.xy + int2(x,y )) / (float)rez, 0);
                count += (uint) (s == next);
            }
            
        }
    }
    
    // IF THRESHOLD IS REACHED, INCREMENT STEP
    //if(count >= (threshold - readMemTex[id.xy].x * nstates)){
    if(count >= threshold){
        state = (state + 1) % nstates;
        writeMemTex[id.xy] = 0;
    } else {
        writeMemTex[id.xy] += 1. / nstates;
    }
    
    if(readMemTex[id.xy].x > 1){
        writeMemTex[id.xy] = 0;
    }
    
    // IF MOUSE POSITION MATCHES ID RESET STATE
    if(distance(id.xy, mouse.xy) < drawRange){
        state = 0;
    }
    
    // WRITE STATE
    writeTex[id.xy] = state;
    
    Render(id, state, count);
}

[numthreads(8, 8, 1)]
void SecondaryNoiseKernel(uint3 id : SV_DispatchThreadID)
{
    // if the state will not be a wall
    if((uint) readTex[id.xy] < (uint) nstates) {
        // add noise
        writeTex[id.xy] = (int)(Random(id.xy).x * nstates);
    }
}
