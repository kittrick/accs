// ------------------------------------------------------------
// Pragmas
// ------------------------------------------------------------

#pragma kernel ResetTextureKernel
#pragma kernel ResetParticlesKernel

#pragma kernel StepKernel
#pragma kernel RenderKernel
#pragma kernel ClearKernel

// ------------------------------------------------------------
// Global Vars
// ------------------------------------------------------------

int width;
int height;
float time;
float drag;
float minMass;
float maxMass;
float2 mousePosition;
float repulsionStrength;
float decayFactor;
int diffuseRange;
float noiseStrength;

// ------------------------------------------------------------
// Textures
// ------------------------------------------------------------

Texture2D<float4> readTex;
SamplerState sampler_readTex;

RWTexture2D<float4> writeTex;
RWTexture2D<float4> outTex;
RWTexture2D<float4> debugTex;

// ------------------------------------------------------------
// Custom Particle Struct
// ------------------------------------------------------------

struct Particle
{
    float2 position;
    float2 velocity;
    float2 acceleration;
    float4 color;
    float mass;
};

// Corresponding ComputeBuffer
RWStructuredBuffer<Particle> particleBuffer;

// ------------------------------------------------------------
// Utilities
// ------------------------------------------------------------

// via "The Art of Code" on YouTube
float2 Random(float2 p) {
    float3 a = frac(p.xyx * float3(123.34, 234.34, 345.65));
    a += dot(a, a + 34.45);
    return frac(float2(a.x * a.y, a.y * a.z));
}

float noise (float2 id) {
    id = id / 10.;
    float2 i = floor(id);
    float2 f = frac(id);

    // Four corners in 2D of a tile
    float a = Random(i).x;
    float b = Random(i + float2(1.0, 0.0)).x;
    float c = Random(i + float2(0.0, 1.0)).x;
    float d = Random(i + float2(1.0, 1.0)).x;

    // Cubic Hermine Curve.  Same as SmoothStep()
    float2 u = f*f*(3.0-2.0*f);

    // Mix 4 coorners percentages
    return lerp(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

float fractalNoise(float2 id, int octaves) {
    float fn = noise(id);
    float n = 0.;
    for(int i = 1; i <= octaves; i++){
        n = noise(
            float2(
                id.x/(float)i+i*1000,
                id.y/(float)i+i*100)
            );
        fn = lerp(fn, n, 1/(float)i);
    }
    fn = fn * fn * fn * 2;
    return fn;
}

float2 RandomDirection(float2 p) {
    return (normalize(2.0 * (Random(p)- 0.5)));
}

float mapRange(float input, float inMin, float inMax, float outMin, float outMax){
    return outMin + (input - inMin) * (outMax - outMin) / (inMax - inMin); 
}

// ------------------------------------------------------------
// Physics Stuff
// ------------------------------------------------------------
Particle applyForce(Particle p, float2 force)
{
    force /= p.mass;
    p.acceleration += force;
    return p;
}

Particle applyDrag(Particle p, float coefficient)
{
    float speed = length(p.velocity);
    
    // The force’s magnitude
    float dragMagnitude = coefficient * speed * speed;
 
    float2 drag = p.velocity;
    drag *= -1;
    
    // The force's direction: -1 * velocity
    drag = normalize(drag);
 
    // Finalize the force: magnitude and direction together.
    drag *= dragMagnitude;
 
    // Apply the force.
    p = applyForce(p, drag);
    return p;
}

Particle attract(Particle p, float2 attractionPoint, float attractionStrength)
{
    float2 force = p.position - attractionPoint;
    float distance = length(force);
    force = normalize(force);
    float strength = (attractionStrength * p.mass) / (distance * distance);
    force *= strength;
    p = applyForce(p, -force);
    return p;
}

Particle repel(Particle p, float2 attractionPoint, float attractionStrength)
{
    float2 force = p.position - attractionPoint;
    float distance = length(force);
    force = normalize(force);
    float strength = (attractionStrength * p.mass) / (distance * distance);
    force *= strength;
    p = applyForce(p, force);
    return p;
}

// ------------------------------------------------------------
// Step
// ------------------------------------------------------------
[numthreads(64, 1, 1)]
void StepKernel(uint3 id: SV_DispatchThreadID)
{   
    // Get particle from buffer
    Particle p = particleBuffer[id.x];
    
    // Apply forces here
    p = applyForce(p, fractalNoise(p.position + float2(time, time), 4) * RandomDirection(p.position) * noiseStrength);
    p = applyDrag(p, drag);
    p = repel(p, mousePosition, repulsionStrength);
    
    // Physics based movement
    p.velocity += p.acceleration;
    p.position += p.velocity;
    p.acceleration *= 0;
    
    // Boundary Wrap
    //if(p.position.x < 0){
    //    p.position = width + p.position;
    //}
    //if(p.position.y < 0){
    //    p.position = height + p.position;
    //}
    //p.position = p.position % float2(width, height);
    // Circular Boundary Wrap
    
    if(length(p.position-float2((float)width/2, (float)height/2)) > (float)width/2.5){
        p.position = float2((float)width/2, (float)height/2);
    }
    
    // Update Buffer
    particleBuffer[id.x] = p;
    
    // Write to Texture;
    int radius = round(p.mass/2);
    for(int y = -radius; y <= radius; y++){
        for(int x = -radius; x <= radius; x++){
            writeTex[round(p.position) - float2(x,y)] = p.color;
        }
    }
}

// ------------------------------------------------------------
// Diffuse
// ------------------------------------------------------------
void Diffuse(uint3 id)
{
    float4 avg = float4(0,0,0,1);
    float count = 0;
    for (int x = -diffuseRange; x <= diffuseRange; x++){
        for (int y = -diffuseRange; y <= diffuseRange; y++){
            // Count the number of cells that is brighter than half brightness
            //float2 pointSample = float2(id.x, id.y);
            float2 pointSample = float2(
                (id.x + x) / (float)width,
                (id.y + y) / (float)height);
            avg += readTex.SampleLevel(sampler_readTex, pointSample, 0);
            count++;
      }
    }
    avg /= count;
    writeTex[id.xy] = avg;
}
// ------------------------------------------------------------
// Clear the Stage
// ------------------------------------------------------------
[numthreads(32, 32, 1)]
void ClearKernel(uint3 id: SV_DispatchThreadID)
{
    Diffuse(id);
    writeTex[id.xy] *= float4(decayFactor, decayFactor, decayFactor, 1);
}

// ------------------------------------------------------------
// Render
// ------------------------------------------------------------
[numthreads(32, 32, 1)]
void RenderKernel(uint3 id: SV_DispatchThreadID)
{
    outTex[id.xy] = writeTex[id.xy];
}

// ------------------------------------------------------------
// Reset
// ------------------------------------------------------------
[numthreads(32, 32, 1)]
void ResetTextureKernel(uint3 id : SV_DispatchThreadID)
{
    writeTex[id.xy] = 0;
}

[numthreads(64, 1, 1)]
void ResetParticlesKernel(uint3 id : SV_DispatchThreadID)
{
    Particle p;

    p.position = Random(id.xx) * float2(width, height) + float2(time, time);
    p.velocity = RandomDirection(id.xx) - RandomDirection(id.xx-10);
    p.acceleration = float2(1,1);
    p.mass = mapRange(Random(id.xx).x, 0, 1, minMass, maxMass);
    float r = mapRange(p.position.x, 0, width, 0, 1);
    float g = mapRange(p.position.y, 0, height, 0, 1);
    p.color = float4(r, g, 1, 1);
    
    particleBuffer[id.x] = p;
}